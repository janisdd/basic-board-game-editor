# Using the interpreter


## building the interpreter without sed

if you need to build the interpreter manually then execute the first part of the `buildCompiler` task --> `node node_modules/.bin/jison simulation/compiler/langCompiler.jison -o simulation/compiler/cliLangCompiler.js`

this will produce the normal jison output

the problem with this output is that this can be used with nodejs and required the `fs` module
but we ware on the frontend and don't need this feature and webpack cannot find the `fs` module (because we ware not on nodejs environment)
thus you need to copy the file `simulation/compiler/cliLangCompiler.js` and name the copy `simulation/compiler/langCompiler.js`

then delete the following lines

```js
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
```

again this is for the usage with nodejs (the main entry function) what we don't need

## the interpreter (parser)

if you want to use the plain compiler generated by jison you can totally do that

all interpreter related files are located at `simulation/`

- `simulation/compiler/langCompiler.jison` is the jison file
- `simulation/compiler/cliLangCompiler.js` is the raw jison output file
- `simulation/compiler/langCompiler.js` is the modified file based on `cliLangCompiler.js` with the nodejs stuff removed

all these files are generated when you run `npm run buildCompiler`

we don't directly execute the code, we crete an ast (abstract syntax tree)
for this we call function from `simulation/builder/executionUnitBuilder.ts` which creates nodes in the tree
the actual nodes in the tree are represented by the *types* in `simulation/model/executionUnit.ts`

in the file `examples/plainParser/index.html` is an example for the usage of the interpreter (only the parser part)
it will parse the code and construct the ast


## the interpreter

after we already included the parser part we now want to interpret the ast (execute the code)

for this we need to build the abstract machine which will execute an action depending on the ast node
run `npm run buildCompilerDist` to get the file `distMisc/interpreter/bbgi.js` (basic board game interpreter)

this can then be included in your html file

see `examples/interpreter/index.html` for an example

also if you want to know which functions cou can call see the file `simulation/machine/AbstractMachine.ts`

>we need to run buildCompilerDist because this will build an bundle file only with all dependencies of `simulation/machine/AbstractMachine.ts`
>we export this as an umd module so we can use it in any environment